# Cheatsheet по RUST

Инструкция по установке Rust доступна [по ссылке](https://www.rust-lang.org/ru/tools/install). Для Linux, обычно достаточно выполнить следующий скрипт:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Может потребоваться добавить путь к исполняемым файлам Rust в путь к исполняемым файлам текущего пользователя. Для этого необходимо добавить в конец файла `~/.profile` следующую строку:

```bash
export PATH="$HOME/.cargo/bin:$PATH"
```

Проверить успешность установки можно командой:

```shell
rustc --version
```

В Visual Studio Code есть целый ряд plug-in-ов, обеспечивающих поддержку Rust:

- [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer) by rust-lang.org
- [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb) by Vadim Chugunov - для отладки кода
- [crates](https://marketplace.visualstudio.com/items?itemName=serayuzgur.crates) by Seray Uzgur - управление зависимостями
- [Even Better TOML](https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml) by tamasfe - синтаксическая подсветка TOML
- [Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner) by Jun Han. Ключевая особенность - он может запускать не весь проект/файл, а только его часть, что потенциально сильно помогает в изучении новых языков программирования

## Создание первого проекта

Создать новый проект можно командой:

```shell
cargo new [имя проекта]
```

Проект будет создан в папке, соответствующей имени проекта.

## Базовые синтаксические конструкции Rust

Вывести сообщение в консоль можно макросами print!() и println!():

```rs
fn main() {
    print!("Hello, World!");
}
```

Функция main() - стартовая точка приложения на Rust.

Форматированный вывод переменных выглядит следующим образом:

```rs
let age = 31;
println!("{}", age);
```

Внутри фигурных скобок мы можем указать позицию аргумента (позиционные аргументы), например:

```rs
let (x, y, z) = (12, 67, 5);
println!("x = {0}, y = {1}, z = {2}", x, y, z);
```

Также могут быть использованы именованные аргументы, в том числе, с вычисляемым значением:

```rs
let (x, y, z) = (12, 67, 5);
println!("sum = {sum}", sum = x + y + z);
```

В Rust может быть использован _string interpolation_:

```rs
let hello: &str = "Hello";
println!("{hello}");
```

В приведённом выше примере используется т.н. _строковый срез_. Аналог в C++ и C# - `span<>`.

Однако, _string interpolation_ в Rust носит ограниченный характер, т.е. внутри строки фигурных скобок нельзя использовать вычисляемые выражения.

Определить неизменное значение можно с помощью ключевого слово let:

```rs
let outer_var = 100;
```

Вычисляемые значения могут быть константными:

```rs
let outer_var = 20 * another_value + 5;
```

Если мы планируем изменять переменную, потребуется добавить модификатор **mut** (mutable - изменяемый):

```rs
let mut age = 1;
```

Инициализация массивов и строк:

```rs
let sparkle_heart = vec![240, 159, 146, 150];

// Поскольку мы знаем, что переданные в параметре байты корректные, мы можем выполнить преобразование unwrap()
let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();
```

## Ввод данных через консоль

Для использования операций ввода вывода необходимо импортировать стандартную библиотеку io:

```rs
use std::io;
```

Мы считываем данные из консоли в строчную переменную. Опеределить такую переменную и проинициализировать её можно командой:

```rs
let mut user_input = String::new();
```

Для чтения из потока ввода используется функция read_line():

```rs
io::stdin().read_line(&mut user_input).expect("Failed to get input");
```

Переменную следует передавать по ссылке (&), обязательно нужно указать, что переменная является изменяемой (_mutable_).

Для того, чтобы избежать предупреждений при сборке приложения, необходимо добавить вызов **expect**(), который обрабатывает особенное возвращаемое значение функции read_line() типа Result. Результирующее значение может быть Err, или OK. Соответственно, вызов expect() приведёт к возникновению ошибки приложения, если будет возвращего значение Err.

> Важно заменить, что если вызвать read_line() с ранее использовавшейся строкой переменной ещё раз, то новый введённый текст будет добавлен к тому, который уже находится в переменной user_input(). Т.е. read_line() обеспечивает накопление вводимых значений. Чтобы избежать накопления, перед повторным вызовом следует сбросить строку, вызвав `user_input.clear();`

Чтобы преобразовать строковое значение к целочисленному, следует использовать функцию parse():

```rs
let in_num : i32 = user_input.trim().parse().expect("Failure to parse");
```

Строковую переменную можно повторно использовать для ввода данных, если перед повторным вызовом read_line() вызвать у переменной метод clear():

```rs
user_input.clear();
```

## Типы данных в Rust

Скалярные типы - это типы описывающие только одно значение в некотором заданном диапазоне. Скалярные типы в Rust:

- целочисленный
- вещественные числа
- логический
- символьный (но не строковый)

Целочисленные типы содержат префикс i (знаковое), либо u (беззнаковое) и длину данных в битах: i8, u8, i16, u16, i32, u32, i64, u64, i128, u128. Также существует архитектуро-зависимая длина: isize, usize.

При определение целочисленных констант, можно указывать тип в константе, чтобы упростить выведение типа (_type inference_). Примеры:

- 20u8 - беззнаковое, восьмибитовое значение 20
- 0xEF01
- 1_000_1000
- 0b1000_1011
- b'A' - байт u8 с кодом ASCII-символа 'A'

Пример вывода чисел в разных системах счисления:

```rs
println!("{num:#b}");
println!("{num:#o}");
println!("{num:#x}");
```

В Debug-режиме Rust включает контроль переполнения целочисленных переменных, но в Release-сборке такой контроль не осуществляется.

Вещественные типы в Rust: f32 - одинарная точность и f64 - двойная точность (используется по умолчанию). Примеры определения переменных:

```rs
let s_pi = 3.1415_f32;      // f32
let d_pi = 3.141592_f64;    // f64
```

Rust требует явного преобразования типов в арифметических операциях. Например:

```rs
let i_op = 10;
let sum = 5.5 as f64 + i_op as f64;
```

Пример вывода вещественных чисел:

```rs
let mut s_pi = 3.14E-4_f32;
println!("{:E}, {:e}", s_pi, s_pi); // "3.14E-4, 3.14e-4"

let mut float = 513.0;
println!("{:.2}", float); // "513.00"
```

```rs
let mut float = 777.0;
let mut prec = 3;

println!("{:.prec$}", float); // "777.000"
```

Вещественные числа представлены в компьютерах по основанию 2 и не хранят в себе целое число десятичных цифр.

Большинство десятичных дробей невозможно в точности представить в двоичном виде. В следствии этого мы получаем их приближенные значения.

Пример потери точности:

```rs
fn main() {
    let difference = 10.5 - 7.4; // 3.0999999999999996
}
```

Rust умеет округлять вещественные числа при выводе:

```rs
fn main() {
    let difference = 10.5 - 7.4; // 3.0999999999999996
    println!("{:.2}", difference); // "3.10"
}
```

В Rust есть различные функции округления вещественных чисел: round(), floor(), ceil().

## Тип char

Тип char используется для хранения одного символа. Тип char имеет размер 4 байта и представляет собой скалярное значение Unicode. Однако строки - это UTF-8, а не Unicode32.

Пример определения:

```rs
fn main() {
    let ch = '大';
    let kor = '조';
    let jap = '字';
}
```

## Составные типы данных

В Rust базовыми составными типами являются кортежи и массивы.

Кортеж (tuple) это коллекция (collection) с фиксированным количеством значений разных типов. Пример:

```rs
fn main() {
    let tup = (500, 6.4, 'h', "Hello"); // (i32, f64, char, &str)
}
```

Для определения одноразмерного кортежа необходимо поставить запятую после значения, чтобы компилятор отличил литерал от кортежа:

```rs
fn main() {
    let tup = (15,); // кортеж
    let var = (15); // целочисленная переменная
}
```

Можно использовать объявление с последующей инициализацией:

```rs
fn main() {
    let tup1: (i32, f64, u8);
    tup1 = (1, 2.0, 3);

    // Или
    let tup2;
    tup2 = (1, 2.0, 3);
}
```

Доступ к элементам кортежа:

```rs
fn main() {
    let tup: (i16, f32, u8) = (500, 6.4, 1);
    println!("{}, {}, {}", tup.0, tup.1, tup.2); // "500, 6.4, 1"
}
```

Для вывода кортежей посредством макроса println!() используется специальный формат: `{:?}`

Rust позволяет выполнять итерирование по элементам tuple стандартным образом, в том числе, задавая шаг. Однако, для того, чтобы выяснить количество элементов в tuple потребуется либо написать вспомогательный макрос, который будет выполняться на этапе компиляции, либо написать trait. Пример кода:

```rs
let tup = (1, 2, 3, 4, 5, 6);
let len = 6; // Явным образом задаём количество элементов в tuple

for index in (1..len).step_by(2) {    
    match index {
        1 => println!("Element at index 1: {}", tup.1),
        3 => println!("Element at index 3: {}", tup.3),
        5 => println!("Element at index 5: {}", tup.5),
        _ => {}
    }
}
```

Вот как может выглядеть реализация trait (выполняется тоже на этапе компиляции):

```rs
trait TupleLen {
    const LEN: usize;
}

impl TupleLen for () {
    const LEN: usize = 0;
}

impl<T1> TupleLen for (T1,) {
    const LEN: usize = 1;
}

impl<T1, T2> TupleLen for (T1, T2) {
    const LEN: usize = 2;
}

impl<T1, T2, T3> TupleLen for (T1, T2, T3) {
    const LEN: usize = 3;
}
```

## Destructuring

Извлечение элементов кортежа в отдельные переменные называется **Destructuring**. Пример:

```rs
let tup = (1, 2.0, '3', "Hello", true);
let (i_num, f_num, ch, str_item,b) = tup;
```

Для возрата пустых значений может использоваться пустой кортеж:

```rs
let em_tup = ();
```

## Определение массива

С аннотацией типа:

```rs
fn main() {
    let arr: [u8; 3] = [1, 2, 3]; // аннотация
}
```

С выведением типа (type inference):

```rs
fn main() {
    let arr = [1_u8, 2, 3];
}
```

В Rust реализован механизм инициализации всего массива одним значением:

```rs
let z_arr1 = [0; 7]; // [0, 0, 0, 0, 0, 0, 0]
```

Мы можем выполнять destructuring элементов массива. Другими словами мы можем заполнить новые переменные элементами массива в одной строке кода:

```rs
let arr = [1, 2, 3, 4, 5];
let [first, second, third, fourth, fifth] = arr;
```

Работая с массивами мы можем использовать метод iter() который возвращает итератор на элементы массива. В Rust есть множество методов, которые позволяют выполнять  агрегацию, например, суммировать все элементы массива:

```rs
let emp_arr = []; // [i32; 0]
println!("{}", emp_arr.iter().sum::<i32>());
```

## Условные операторы

В Rust оператор сравнения не требует использования круглых скобок:

```rs
if num > 5 {
    // ...
}
```

Попытка использование в условном операторе не логического типа приведёт к ошибке компиляции!

Сревнение строк осуществляется также как и у скалярных типов:

```rs
if in_str == "Hello" {
    // ...
}
```

Точно так же можно сравнивать и массивы:

```rs
fn main() {
    let mut array1 = [1, 2, 3];
    let mut array2 = [1, 2, 3];

    if array1 == array2 {
        println!("Массивы {:?} и {:?} равны", array1, array2);
    } else {
        println!("Массивы {:?} и {:?} не равны", array1, array2);
    }
}
```

Сравнивать можно все типы, для которых реализованы **traits** (свойства): **PartialEq**, или **Eq**.

Равенство вещественных чисел следует избегать, т.к. из-за округления очень вероятны логические ошибки.

В Rust отсутствует тернарный оператор, вместо которого может быть использована конструкция:

```rs
let max = if first > second { first } else { second };
```

## Передача строки

Для C++ программистов может быть достаточно необычным возврат строки из функции. Тип `str` является типом с динамическим размером и не совестим с типом `String`. Чтобы привести str к String, нужно использовать функцию `to_string()`. Однако, такое преобразование практически равнозначно клонированию строки.

В Rust нельзя вернуть из функции str - можно только String.

String предполагает передачу владения (ownership).

Чтобы минимизировать создание новых объектов мы можем передавать не str, а т.н. срез - т.е. ссылку на str. Это можно сделать конструкцией `&str`. Символ амперсанд `&` не предполагает передачу владения - данные передаются по ссылке.

## Сопоставление (match)

В Rust есть управляющая конструкция match, которая выглядит приблизительно так:

```rs
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

В зависимости от значения coin, будет выбран некоторый элемент и возвращён из функции. Работает почти так же, как и **switch expression** в C\#.

В приведённом выше примере для того, чтобы вернуть значение не используется ключевое слово return - оно считается избыточным. Возвращается значение, которое не заканчивается точкой с запятой.

Более сложный пример:

```rs
match number {
    // Match a single value
    1 => println!("One!"),
    // Match several values
    2 | 3 | 5 | 7 | 11 => println!("This is a prime"),
    // TODO ^ Try adding 13 to the list of prime values
    // Match an inclusive range
    13..=19 => println!("A teen"),
    // Handle the rest of cases
    _ => println!("Ain't special"),
    // TODO ^ Try commenting out this catch-all arm
}
```

## Затенение

Пример затенения:

```rs
let mut guess = String::new();
let guess: u32 = guess.trim().parse()
	.expect("Пожалуйста, наберите число!");
```

Мы используем одно и тоже имя guess для переменной типа String и пременной типа u32 строкой ниже. Компилятор поймёт, что разговор идёт о двух разных переменных и скомпилирует приложение с использованием двух переменных разных типов. Цель затенения - избежать создания дополнительных переменных, которые дублируют одно и тоже значение, но разных типов. Например, начала мы вводим строку guest из консоли, но нам нужно конвертировать её в тип u32. Если бы не было затенения, то потребовалось бы использовать переменные с разными именами, например: str_guess и n_guess.

## Почему в Rust может быть возвращено значение без ключевого слово return

В языке Rust есть определены понятия инструкций и выражений:

- Инструкция (**Statement**) - наименьшая единица языка, выполняющая какое-то действие без возврата значения
- Выражение (**Expression**) - вычисляемый фрагмент кода с возвратом значения

Инструкции бывают двух типов:

- Инструкции-объявления (**Declaration statements**) - вводят одно или несколько имён во включающий блок инструкций, т.е. в {}
- Инструкции-выражения (**Expression statements**) - вычисляют выражение и игнорируют его результат

Когда мы используем конструкцию вида `{ 10 }`, она трактуется как выражение, не являющееся частью инструкции. И такая конструкция автоматически возвращает значение. По этой причине, мы не должны явным образом писать ключевое слово return, например, вот в этом коде:

```rs
fn main() {
    let flag = 0;
    let num = if flag == 0 {
        let x = 10;
        x + 1
    } else {
        let x = 10;
        x + 1
    };

    println!("Значение переменной num = {num}"); // "Значение переменной num = 11"
}
```

Ещё один пример очень красивой вычислительной конструкции в Rust:

```rs
let wages = if hours <= 40 {
    hours as f64 * 1500.0
} else {
    (40.0 * 1500.0) + ((hours as f64 - 40.0) * 1.5 * 1500.0 )
};
```

## Очень красивые конструкции for

Переменная цикла определяется автоматически, диапазон можно указать явным образом:

```rs
for index in 3..-1 {
    // ...
}
```

## Форматная строка для битового вывода

Типовой спецификатор - `{:b}`. Если нужно вывести ограниченное количество бит, то следует указать количество выводимых бит, например: `{:8b}`. 

Мы можем использовать имя переменной в спецификаторе, например: `{:width$b}`

Если необходимо сделать выравнивание по левому краю, добавив недостающий нулевые значения, то длину следует начать с нуля: `{:0width$b}`

```rs
fn main() {
    println!("{:08b}", 1u8);
}
```

## Возведение числа в степень n

Пример:

```rs
let base: u32 = 2;
let result = base.pow(n);
```

## Циклы

Простой цикл в заданном диапазоне:

```rs
for i in 0..10 {
    println!("{i}");
}
```

Последнее значение в диапазоне исключается из диапазона, но если нужно включить последнее значение в диапазон, то выполняется следующий трюк:

```rs
for i in 0..=10 {
    println!("{i}");
}
```

Довольно изящное решение.

Начало и конец диапазона можно передать через переменные:

```rs
let (start, end) = (1, 10);
for i in start..=end {
    println!("{i}");
}
```

В Rust можно использовать бесконечный диапазон. Например:

```rs
for i in -10.. {
    println!("{i}");
}
```

Мы можем задать шаг диапазона посредством вызова функции **step_by**():

```rs
for i in (0..10).step_by(2) {
    println!("{i}");
}
```

Если мы хотим развернуть действие итератора, то следует использовать функцию **rev**(), как в примере:

```rs
for i in (0..4).rev() {
    println!("{i}");
}
```

Важно понимать, что в выборку попадают все значения из указанного диапазона. Например, в приведённом выше примере результат будет таким: 3, 2, 1, 0.

Оценочное мнение: в Rust изначально применены итераторы в конструкции оператора for, что является высокоуровневым подходом, в отличие от низкоуровневого подхода, принятого в Си и С++.

## Работа с массивами

Пример создания массива и заполнения его данными с использованием индекса:

```rs
let mut array = [0; 100];
for item in 0..array.len() {
    array[item] = item;
}
```

_Идиоматический_ способ перебора коллекций:

```rs
let array = [0, 1, 1, 2, 3, 5, 8, 13, 21];
for iter in array {
    println!("{iter}");
}
```
Термин "идиоматический" относится к стилю написания кода, означает, что конструкция соответствует общепринятым практикам и паттернам, характерным для данного языка. Идиоматический код использует особенности и возможности языка, чтобы сделать код более читаемым, эффективным и понятным для других разработчиков, знакомых с этим языком.

Например, в языке Python идиоматический код может включать использование списковых включений (list comprehensions) для создания списков, а в JavaScript — использование функций высшего порядка и методов массивов, таких как map, filter и reduce. Идиоматический подход помогает избежать избыточности и делает код более "естественным" для данного языка, что облегчает его поддержку и развитие.

## Замена вызова expect() на оператор match

**Этот подраздел имеет критичное значение!**

Многие из функций Rust Runtime возвращают значение типа Option<T>, или Result. Идея состоит в том, чтобы обеспечить возможность информировать вызывающий код о том, что в процессе выполнения функции возникла некоторая ошибка. В Си и C++ используются другие подходы, которые разработчики Rust признали либо опасными, либо низко эффективными.

В Си часто ошибка возвращается как специальное значение. Например, если функция отрабатывает штатно, то она возвращает целой число, а если возникла ошибка, то отрицательное, в разъяснением кода ошибки. Этот подход сильно ухудшает читаемость кода, т.к. нужно знать особенности реализации, буквально, каждой вызываемой функции. Можно сказать, что эта языковая особенность является одной из наиболее проблемных в Си.

В С++, в случае возникновения ошибки, может быть сброшено исключение (exception), которое может быть обработано выше по коду. Удобство использования exception состоит в том, что в нём можно передать большое количество информации для идентификации ошибки, а также обработать несколькими уровнями выше по stack-у вызовов. Проблемы с exception в C++:

- стоимость сброса и обработки исключений высокие
- добавляется большое количество дополнительного кода, как для обработки исключения так и для реализации классов, производных от std::exception
- можно не обработать исключение и это приведёт к аварийному завершению приложения

Разработчики Rust решили пойти по другому пути - функции Runtime часто возвращают значение типа Option<T>, или Result, в котором есть как возвращаемое значение, так и флаг возникновения ошибки. Функция expect() проверяет, завершился ли вызов ошибкой и если завершился, то выдаёт сообщение об ошибке и прекращает его работу. Однако чаще используется конструкция match, которая позволяет отработать ошибку альтернативным образом. Например:

```rs
    let mut input = String::new();

    while input.trim() != "#" {
        input.clear();
        std::io::stdin()
            .read_line(&mut input)
            .expect("Ошибка при чтении ввода.");
        println!("Содержимое input: {:#?}", input);

        let number: i32 = match input.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("Вы ввели число: {number}");
    }
```

В приведённом выше коде, в случае, если в формат введённых данных не будет соответствовать целочисленному значению (i32), то приложение не завершиться ошибкой, а продолжит работу с начала цикла while - в проверке match/Err используется оператор continue.

### Посимвольная обработка ввода

Пример, в котором проверяется, что каждый введённый символ является цифрой:

```rs
for ch in input.trim().chars() {
    if ch.is_numeric() == false {
        is_number = false;
    }
}
```

Более простой вариант (требующий хорошего знания Runtime):

```rs
if input.trim().chars().all(char::is_numeric) {
}
```

Создать из строки коллекцию отдельных символов можно используя `chars.collect()`:

```rs
let chars: Vec<char> = num.to_string().chars().collect();
```

## Работа со строками. Slicing

В задаче "Deleter" на Stepik.org требовалось удалить k первых цифр числа n. Моё решение было следующим:

```rs
let n = read_input();
let k = read_input() as usize;

let str = n.to_string();

if k >= str.len() {
    print!("k >= n");
} else {
    let substring = &str[k..];
    println!("{}", substring);
}
```

В приведённом выше коде, ключевой является строка `&str[k..]`, в которой выполняется операция выделения подстроки с указанием диапазона. Очень наглядная языковая конструкция, рукоплещу!

Сама по себе конструкция очень интересная. Выражение `str[k..]` создаёт slice, т.е. часть строки, которая начинается с k-того символа и заканчивается концом строки. Символ-амперсанд (&) перед конструкцией указывает на то, что нужно создать ссылку на объект (строка), а не передавать владение объектом. Передача ссылки на строку позволяет избежать копирования объекта. Таким образом, конструкция не только лаконичная, но и эффективная.
