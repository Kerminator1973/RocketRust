# Cheatsheet по RUST

Инструкция по установке Rust доступна [по ссылке](https://www.rust-lang.org/ru/tools/install). Для Linux, обычно достаточно выполнить следующий скрипт:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Может потребоваться добавить путь к исполняемым файлам Rust в путь к исполняемым файлам текущего пользователя. Для этого необходимо добавить в конец файла `~/.profile` следующую строку:

```bash
export PATH="$HOME/.cargo/bin:$PATH"
```

Проверить успешность установки можно командой:

```shell
rustc --version
```

В Visual Studio Code есть целый ряд plug-in-ов, обеспечивающих поддержку Rust:

- [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer) by rust-lang.org
- [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb) by Vadim Chugunov - для отладки кода
- [crates](https://marketplace.visualstudio.com/items?itemName=serayuzgur.crates) by Seray Uzgur - управление зависимостями
- [Even Better TOML](https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml) by tamasfe - синтаксическая подсветка TOML
- [Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner) by Jun Han. Ключевая особенность - он может запускать не весь проект/файл, а только его часть, что потенциально сильно помогает в изучении новых языков программирования

## Создание первого проекта

Создать новый проект можно командой:

```shell
cargo new [имя проекта]
```

Проект будет создан в папке, соответствующей имени проекта.


## Базовые синтаксические конструкции Rust

Вывести сообщение в консоль можно макросами print!() и println!():

```rs
fn main() {
    print!("Hello, World!");
}
```

Функция main() - стартовая точка приложения на Rust.

Форматированный вывод переменных выглядит следующим образом:

```rs
let age = 31;
println!("{}", age);
```

Внутри фигурных скобок мы можем указать позицию аргумента (позиционные аргументы), например:

```rs
let (x, y, z) = (12, 67, 5);
println!("x = {0}, y = {1}, z = {2}", x, y, z);
```

Также могут быть использованы именованные аргументы, в том числе, с вычисляемым значением:

```rs
let (x, y, z) = (12, 67, 5);
println!("sum = {sum}", sum = x + y + z);
```

В Rust может быть использован _string interpolation_:

```rs
let hello: &str = "Hello";
println!("{hello}");
```

В приведённом выше примере используется т.н. _строковый срез_. Аналог в C++ и C# - `span<>`.

Однако, _string interpolation_ в Rust носит ограниченный характер, т.е. внутри строки фигурных скобок нельзя использовать вычисляемые выражения.

Определить неизменное значение можно с помощью ключевого слово let:

```rs
let outer_var = 100;
```

Вычисляемые значения могут быть константными:

```rs
let outer_var = 20 * another_value + 5;
```

Если мы планируем изменять переменную, потребуется добавить модификатор **mut** (mutable - изменяемый):

```rs
let mut age = 1;
```

Инициализация массивов и строк:

```rs
let sparkle_heart = vec![240, 159, 146, 150];

// Поскольку мы знаем, что переданные в параметре байты корректные, мы можем выполнить преобразование unwrap()
let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();
```

## Ввод данных через консоль

Для использования операций ввода вывода необходимо импортировать стандартную библиотеку io:

```rs
use std::io;
```

Мы считываем данные из консоли в строчную переменную. Опеределить такую переменную и проинициализировать её можно командой:

```rs
let mut user_input = String::new();
```

Для чтения из потока ввода используется функция read_line():

```rs
io::stdin().read_line(&mut user_input).expect("Failed to get input");
```

Переменную следует передавать по ссылке (&), обязательно нужно указать, что переменная является изменяемой (_mutable_).

Для того, чтобы избежать предупреждений при сборке приложения, необходимо добавить вызов **expect**(), который обрабатывает особенное возвращаемое значение функции read_line() типа Result. Результирующее значение может быть Err, или OK. Соответственно, вызов expect() приведёт к возникновению ошибки приложения, если будет возвращего значение Err.

Чтобы преобразовать строковое значение к целочисленному, следует использовать функцию parse():

```rs
let in_num : i32 = user_input.trim().parse().expect("Failure to parse");
```

Строковую переменную можно повторно использовать для ввода данных, если перед повторным вызовом read_line() вызвать у переменной метод clear():

```rs
user_input.clear();
```

## Типы данных в Rust

Скалярные типы - это типы описывающие только одно значение в некотором заданном диапазоне. Скалярные типы в Rust:

- целочисленный
- вещественные числа
- логический
- символьный (но не строковый)

Целочисленные типы содержат префикс i (знаковое), либо u (беззнаковое) и длину данных в битах: i8, u8, i16, u16, i32, u32, i64, u64, i128, u128. Также существует архитектуро-зависимая длина: isize, usize.

При определение целочисленных констант, можно указывать тип в константе, чтобы упростить выведение типа (_type inference_). Примеры:

- 20u8 - беззнаковое, восьмибитовое значение 20
- 0xEF01
- 1_000_1000
- 0b1000_1011
- b'A' - байт u8 с кодом ASCII-символа 'A'

Пример вывода чисел в разных системах счисления:

```rs
println!("{num:#b}");
println!("{num:#o}");
println!("{num:#x}");
```

В Debug-режиме Rust включает контроль переполнения целочисленных переменных, но в Release-сборке такой контроль не осуществляется.

Вещественные типы в Rust: f32 - одинарная точность и f64 - двойная точность (используется по умолчанию). Примеры определения переменных:

```rs
let s_pi = 3.1415_f32;      // f32
let d_pi = 3.141592_f64;    // f64
```

Rust требует явного преобразования типов в арифметических операциях. Например:

```rs
let i_op = 10;
let sum = 5.5 as f64 + i_op as f64;
```

Пример вывода вещественных чисел:

```rs
let mut s_pi = 3.14E-4_f32;
println!("{:E}, {:e}", s_pi, s_pi); // "3.14E-4, 3.14e-4"

let mut float = 513.0;
println!("{:.2}", float); // "513.00"
```

```rs
let mut float = 777.0;
let mut prec = 3;

println!("{:.prec$}", float); // "777.000"
```

Вещественные числа представлены в компьютерах по основанию 2 и не хранят в себе целое число десятичных цифр.

Большинство десятичных дробей невозможно в точности представить в двоичном виде. В следствии этого мы получаем их приближенные значения.

Пример потери точности:

```rs
fn main() {
    let difference = 10.5 - 7.4; // 3.0999999999999996
}
```

Rust умеет округлять вещественные числа при выводе:

```rs
fn main() {
    let difference = 10.5 - 7.4; // 3.0999999999999996
    println!("{:.2}", difference); // "3.10"
}
```

В Rust есть различные функции округления вещественных чисел: round(), floor(), ceil().

## Тип char

Тип char используется для хранения одного символа. Тип char имеет размер 4 байта и представляет собой скалярное значение Unicode.

Пример определения:

```rs
fn main() {
    let ch = '大';
    let kor = '조';
    let jap = '字';
}
```

## Составные типы данных

В Rust базовыми составными типами являются кортежи и массивы.

Кортеж (tuple) это коллекция (collection) с фиксированным количеством значений разных типов. Пример:

```rs
fn main() {
    let tup = (500, 6.4, 'h', "Hello"); // (i32, f64, char, &str)
}
```

Для определения одноразмерного кортежа необходимо поставить запятую после значения, чтобы компилятор отличил литерал от кортежа:

```rs
fn main() {
    let tup = (15,); // кортеж
    let var = (15); // целочисленная переменная
}
```

Можно использовать объявление с последующей инициализацией:

```rs
fn main() {
    let tup1: (i32, f64, u8);
    tup1 = (1, 2.0, 3);

    // Или
    let tup2;
    tup2 = (1, 2.0, 3);
}
```

Доступ к элементам кортежа:

```rs
fn main() {
    let tup: (i16, f32, u8) = (500, 6.4, 1);
    println!("{}, {}, {}", tup.0, tup.1, tup.2); // "500, 6.4, 1"
}
```

Для вывода кортежей посредством макроса println!() используется специальный формат: `{:?}`

Rust позволяет выполнять итерирование по элементам tuple стандартным образом, в том числе, задавая шаг. Однако, для того, чтобы выяснить количество элементов в tuple потребуется либо написать вспомогательный макрос, который будет выполняться на этапе компиляции, либо написать trait. Пример кода:

```rs
let tup = (1, 2, 3, 4, 5, 6);
let len = 6; // Явным образом задаём количество элементов в tuple

for index in (1..len).step_by(2) {    
    match index {
        1 => println!("Element at index 1: {}", tup.1),
        3 => println!("Element at index 3: {}", tup.3),
        5 => println!("Element at index 5: {}", tup.5),
        _ => {}
    }
}
```

Вот как может выглядеть реализация trait (выполняется тоже на этапе компиляции):

```rs
trait TupleLen {
    const LEN: usize;
}

impl TupleLen for () {
    const LEN: usize = 0;
}

impl<T1> TupleLen for (T1,) {
    const LEN: usize = 1;
}

impl<T1, T2> TupleLen for (T1, T2) {
    const LEN: usize = 2;
}

impl<T1, T2, T3> TupleLen for (T1, T2, T3) {
    const LEN: usize = 3;
}
```

## Destructuring

Извлечение элементов кортежа в отдельные переменные называется **Destructuring**. Пример:

```rs
let tup = (1, 2.0, '3', "Hello", true);
let (i_num, f_num, ch, str_item,b) = tup;
```

Для возрата пустых значений может использоваться пустой кортеж:

```rs
let em_tup = ();
```

## Определение массива

С аннотацией типа:

```rs
fn main() {
    let arr: [u8; 3] = [1, 2, 3]; // аннотация
}
```

С выведением типа (type inference):

```rs
fn main() {
    let arr = [1_u8, 2, 3];
}
```

В Rust реализован механизм инициализации всего массива одним значением:

```rs
let z_arr1 = [0; 7]; // [0, 0, 0, 0, 0, 0, 0]
```

Мы можем выполнять destructuring элементов массива. Другими словами мы можем заполнить новые переменные элементами массива в одной строке кода:

```rs
let arr = [1, 2, 3, 4, 5];
let [first, second, third, fourth, fifth] = arr;
```

Работая с массивами мы можем использовать метод iter() который возвращает итератор на элементы массива. В Rust есть множество методов, которые позволяют выполнять  агрегацию, например, суммировать все элементы массива:

```rs
let emp_arr = []; // [i32; 0]
println!("{}", emp_arr.iter().sum::<i32>());
```

## Условные операторы

В Rust оператор сравнения не требует использования круглых скобок:

```rs
if num > 5 {
    // ...
}
```

Попытка использование в условном операторе не логического типа приведёт к ошибке компиляции!

Сревнение строк осуществляется также как и у скалярных типов:

```rs
if in_str == "Hello" {
    // ...
}
```

Точно так же можно сравнивать и массивы:

```rs
fn main() {
    let mut array1 = [1, 2, 3];
    let mut array2 = [1, 2, 3];

    if array1 == array2 {
        println!("Массивы {:?} и {:?} равны", array1, array2);
    } else {
        println!("Массивы {:?} и {:?} не равны", array1, array2);
    }
}
```

Сравнивать можно все типы, для которых реализованы traits (свойства): **PartialEq**, или **Eq**.

Равенство вещественных чисел следует избегать, т.к. из-за округления очень вероятны логические ошибки.

В Rust отсутствует тернарный оператор, вместо которого может быть использована конструкция:

```rs
let max = if first > second { first } else { second };
```
