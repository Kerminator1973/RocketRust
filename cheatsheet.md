# Cheatsheet по RUST

Инструкция по установке Rust доступна [по ссылке](https://www.rust-lang.org/ru/tools/install). Для Linux, обычно достаточно выполнить следующий скрипт:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Может потребоваться добавить путь к исполняемым файлам Rust в путь к исполняемым файлам текущего пользователя. Для этого необходимо добавить в конец файла `~/.profile` следующую строку:

```bash
export PATH="$HOME/.cargo/bin:$PATH"
```

Проверить успешность установки можно командой:

```shell
rustc --version
```

В Visual Studio Code есть целый ряд plug-in-ов, обеспечивающих поддержку Rust:

- [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer) by rust-lang.org
- [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb) by Vadim Chugunov - для отладки кода
- [crates](https://marketplace.visualstudio.com/items?itemName=serayuzgur.crates) by Seray Uzgur - управление зависимостями
- [Even Better TOML](https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml) by tamasfe - синтаксическая подсветка TOML
- [Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner) by Jun Han. Ключевая особенность - он может запускать не весь проект/файл, а только его часть, что потенциально сильно помогает в изучении новых языков программирования

## Базовые синтаксические конструкции Rust

Вывести сообщение в консоль можно макросами print!() и println!():

```rs
fn main() {
    print!("Hello, World!");
}
```

Функция main() - стартовая точка приложения на Rust.

Форматированный вывод переменных выглядит следующим образом:

```rs
let age = 31;
println!("{}", age);
```

Внутри фигурных скобок мы можем указать позицию аргумента (позиционные аргументы), например:

```rs
let (x, y, z) = (12, 67, 5);
println!("x = {0}, y = {1}, z = {2}", x, y, z);
```

Также могут быть использованы именованные аргументы, в том числе, с вычисляемым значением:

```rs
let (x, y, z) = (12, 67, 5);
println!("sum = {sum}", sum = x + y + z);
```

В Rust может быть использован _string interpolation_:

```rs
let hello: &str = "Hello";
println!("{hello}");
```

В приведённом выше примере используется т.н. _строковый срез_. Аналог в C++ и C# - `span<>`.

Однако, _string interpolation_ в Rust носит ограниченный характер, т.е. внутри строки фигурных скобок нельзя использовать вычисляемые выражения.

Определить неизменное значение можно с помощью ключевого слово let:

```rs
let outer_var = 100;
```

Вычисляемые значения могут быть константными:

```rs
let outer_var = 20 * another_value + 5;
```

Если мы планируем изменять переменную, потребуется добавить модификатор **mut** (mutable - изменяемый):

```rs
let mut age = 1;
```

Инициализация массивов и строк:

```rs
let sparkle_heart = vec![240, 159, 146, 150];

// Поскольку мы знаем, что переданные в параметре байты корректные, мы можем выполнить преобразование unwrap()
let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();
```

## Ввод данных через консоль

Для использования операций ввода вывода необходимо импортировать стандартную библиотеку io:

```rs
use std::io;
```

Мы считываем данные из консоли в строчную переменную. Опеределить такую переменную и проинициализировать её можно командой:

```rs
let mut user_input = String::new();
```

Для чтения из потока ввода используется функция read_line():

```rs
io::stdin().read_line(&mut user_input).expect("Failed to get input");
```

Переменную следует передавать по ссылке (&), обязательно нужно указать, что переменная является изменяемой (_mutable_).

Для того, чтобы избежать предупреждений при сборке приложения, необходимо добавить вызов **expect**(), который обрабатывает особенное возвращаемое значение функции read_line() типа Result. Результирующее значение может быть Err, или OK. Соответственно, вызов expect() приведёт к возникновению ошибки приложения, если будет возвращего значение Err.

Чтобы преобразовать строковое значение к целочисленному, следует использовать функцию parse():

```rs
let in_num : i32 = user_input.trim().parse().expect("Failure to parse");
```

## Типы данных в Rust

Скалярные типы - это типы описывающие только одно значение в некотором заданном диапазоне. Скалярные типы в Rust:

- целочисленный
- вещественные числа
- логический
- символьный (но не строковый)

Целочисленные типы содержат префикс i (знаковое), либо u (беззнаковое) и длину данных в битах: i8, u8, i16, u16, i32, u32, i64, u64, i128, u128. Также существует архитектуро-зависимая длина: isize, usize.

При определение целочисленных констант, можно указывать тип в константе, чтобы упростить выведение типа (_type inference_). Примеры:

- 20u8 - беззнаковое, восьмибитовое значение 20
- 0xEF01
- 1_000_1000
- 0b1000_1011
- b'A' - байт u8 с кодом ASCII-символа 'A'
